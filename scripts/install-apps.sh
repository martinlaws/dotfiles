#!/bin/bash
#
# GUI Application Installation - Interactive app selection and installation
#

# Source libraries
SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "$0")/.." && pwd)}"
# shellcheck source=scripts/lib/detect.sh
. "$SCRIPT_DIR/scripts/lib/detect.sh"
# shellcheck source=scripts/lib/ui.sh
. "$SCRIPT_DIR/scripts/lib/ui.sh"

# Verify Homebrew is available before attempting app installation
if ! command -v brew >/dev/null 2>&1; then
    echo ""
    ui_error "Homebrew is not installed or not in PATH"
    echo ""
    echo "Please ensure Homebrew installation completed successfully."
    echo "You may need to:"
    echo "  1. Check if /opt/homebrew/bin/brew exists (Apple Silicon)"
    echo "  2. Check if /usr/local/bin/brew exists (Intel)"
    echo "  3. Re-run the setup script"
    echo ""
    exit 1
fi

# Display section header
echo ""
ui_header "GUI Application Installation"
echo ""

# Parse Brewfile.apps to extract apps by category
parse_apps_by_category() {
    local brewfile="$SCRIPT_DIR/config/Brewfile.apps"
    local current_category=""

    while IFS= read -r line; do
        # Detect category headers like "# Browsers"
        if [[ $line =~ ^#[[:space:]]+(.*) ]]; then
            local heading="${BASH_REMATCH[1]}"
            # Category headers are standalone comments, not inline
            if [[ ! $line =~ cask ]]; then
                current_category="$heading"
            fi
        fi

        # Extract cask entries
        if [[ $line =~ ^cask[[:space:]]+\"([^\"]+)\"[[:space:]]*#[[:space:]]*(.+)$ ]]; then
            local app="${BASH_REMATCH[1]}"
            local rest="${BASH_REMATCH[2]}"

            # Parse priority and description
            local priority=""
            local description=""
            if [[ $rest =~ ^\(([^\)]+)\)[[:space:]]*(.+)$ ]]; then
                priority="${BASH_REMATCH[1]}"
                description="${BASH_REMATCH[2]}"
            else
                description="$rest"
            fi

            echo "$current_category|$app|$priority|$description"
        fi
    done < "$brewfile"
}

# Generate a temporary Brewfile with selected apps
generate_brewfile() {
    local array_name="$1"
    local tmpfile="$2"

    cat > "$tmpfile" << 'EOF'
# Temporary Brewfile - Generated by install-apps.sh
EOF

    # Use eval to access array by name (Bash 3.2 compatible)
    eval "for app in \"\${${array_name}[@]}\"; do
        echo \"cask \\\"\$app\\\"\" >> \"$tmpfile\"
    done"
}

# Parse all apps into arrays
ALL_APPS=()
while IFS='|' read -r category app priority description; do
    ALL_APPS+=("$app")

    # Store app details for display (sanitize app name for variable names)
    safe_name=$(echo "$app" | tr -c '[:alnum:]' '_')
    eval "APP_${safe_name}_CATEGORY=\"$category\""
    eval "APP_${safe_name}_PRIORITY=\"$priority\""
    eval "APP_${safe_name}_DESCRIPTION=\"$description\""
done <<EOF
$(parse_apps_by_category)
EOF

# Show installation mode selection
ui_info "How would you like to install applications?"
echo ""

MODE=$(gum choose \
    "Install all (recommended)" \
    "Choose categories" \
    "Choose individual apps")

if [ -z "$MODE" ]; then
    ui_info "Installation cancelled"
    exit 0
fi

echo ""

# Array to hold selected apps
SELECTED_APPS=()

case "$MODE" in
    "Install all (recommended)")
        # Use all apps
        SELECTED_APPS=("${ALL_APPS[@]}")
        ui_success "Installing all applications"
        ;;

    "Choose categories")
        # Multi-select categories
        ui_info "Select categories to install (space to select, enter to confirm):"
        echo ""

        CATEGORIES=$(gum choose --no-limit \
            "Browsers (essential)" \
            "Dev Tools (recommended)" \
            "Communication (essential)" \
            "Creative (optional)" \
            "Utilities (recommended)" \
            "Productivity (recommended)" \
            "Gaming (optional)")

        if [ -z "$CATEGORIES" ]; then
            ui_info "No categories selected, installation cancelled"
            exit 0
        fi

        echo ""

        # Map selected categories to apps
        while IFS='|' read -r category app priority description; do
            # Check if this app's category was selected
            if echo "$CATEGORIES" | grep -q "^${category}"; then
                SELECTED_APPS+=("$app")
            fi
        done <<EOF
$(parse_apps_by_category)
EOF

        ui_success "Selected ${#SELECTED_APPS[@]} apps from categories"
        ;;

    "Choose individual apps")
        # Multi-select individual apps with category grouping
        ui_info "Select individual apps to install (space to select, enter to confirm):"
        echo ""

        # Build selection list with category headers and apps
        SELECTION_LIST=()
        CURRENT_CATEGORY=""

        while IFS='|' read -r category app priority description; do
            # Add category header if changed
            if [ "$category" != "$CURRENT_CATEGORY" ]; then
                SELECTION_LIST+=("--- $category ---")
                CURRENT_CATEGORY="$category"
            fi

            # Format app line with priority and description
            if [ -n "$priority" ]; then
                SELECTION_LIST+=("  $app ($priority) - $description")
            else
                SELECTION_LIST+=("  $app - $description")
            fi
        done <<EOF
$(parse_apps_by_category)
EOF

        # Show selection
        SELECTIONS=$(printf '%s\n' "${SELECTION_LIST[@]}" | gum choose --no-limit)

        if [ -z "$SELECTIONS" ]; then
            ui_info "No apps selected, installation cancelled"
            exit 0
        fi

        echo ""

        # Extract app names from selections (skip category headers)
        while IFS= read -r line; do
            if [[ ! $line =~ ^--- ]]; then
                # Extract app name from formatted line
                if [[ $line =~ ^[[:space:]]+([a-z0-9@.-]+) ]]; then
                    SELECTED_APPS+=("${BASH_REMATCH[1]}")
                fi
            fi
        done <<< "$SELECTIONS"

        ui_success "Selected ${#SELECTED_APPS[@]} individual apps"
        ;;
esac

echo ""

# Check if there are apps to install
if [ ${#SELECTED_APPS[@]} -eq 0 ]; then
    ui_error "No applications selected"
    exit 1
fi

# Generate temporary Brewfile
TEMP_BREWFILE=$(mktemp)
trap 'rm -f "$TEMP_BREWFILE"' EXIT

generate_brewfile SELECTED_APPS "$TEMP_BREWFILE"

# Check if apps are already installed
if brew bundle check --file="$TEMP_BREWFILE" >/dev/null 2>&1; then
    ui_success "All selected apps already installed"
    exit 0
fi

# Install apps with progress
ui_section "Installing applications..."
echo ""

if [ "$VERBOSE" = true ]; then
    # Verbose mode: show full brew output
    echo "Running: brew bundle install --file=$TEMP_BREWFILE"
    brew bundle install --file="$TEMP_BREWFILE"
    INSTALL_STATUS=$?
else
    # Normal mode: use spinner
    ui_spin "Installing selected apps..." "brew bundle install --file='$TEMP_BREWFILE' 2>&1"
    INSTALL_STATUS=$?
fi

# Check for partial failures
if [ $INSTALL_STATUS -ne 0 ] || ! brew bundle check --file="$TEMP_BREWFILE" >/dev/null 2>&1; then
    echo ""
    ui_info "Checking for failed installations..."

    # Get list of failed apps
    FAILED_APPS=()
    for app in "${SELECTED_APPS[@]}"; do
        # Check if app is installed via brew
        if ! brew list --cask "$app" >/dev/null 2>&1; then
            FAILED_APPS+=("$app")
        fi
    done

    # Handle failed apps
    if [ ${#FAILED_APPS[@]} -gt 0 ]; then
        echo ""
        ui_error "Some apps failed to install:"
        for app in "${FAILED_APPS[@]}"; do
            echo "  - $app"
        done
        echo ""

        # Calculate successful installations
        SUCCESS_COUNT=$((${#SELECTED_APPS[@]} - ${#FAILED_APPS[@]}))
        ui_info "Successfully installed: $SUCCESS_COUNT/${#SELECTED_APPS[@]} apps"
        echo ""

        # Prompt to continue
        if ui_confirm "Continue anyway?"; then
            ui_info "Continuing with partial installation..."
            # Export failed apps for report
            export SKIPPED_APPS="${FAILED_APPS[*]}"
        else
            ui_error "Installation aborted"
            exit 1
        fi
    fi
else
    ui_success "All selected apps installed successfully"
fi

echo ""
