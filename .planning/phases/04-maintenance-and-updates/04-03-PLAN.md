---
phase: 04-maintenance-and-updates
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - setup
  - scripts/run-updates.sh
  - scripts/show-report.sh
autonomous: true

must_haves:
  truths:
    - "Running setup detects previous installation and shows 'Detected previous setup' message"
    - "User confirms before any updates run"
    - "User can select which update categories to run via multi-select checklist"
    - "Completion report shows specific packages upgraded (e.g., nodejs 20.0->20.1, git 2.40->2.41)"
    - "Completion report shows what was skipped and any errors"
  artifacts:
    - path: "setup"
      provides: "Entry point with update mode detection"
      contains: "state_exists"
    - path: "scripts/run-updates.sh"
      provides: "Update mode orchestration with multi-select category selection"
      contains: "gum choose --no-limit"
    - path: "scripts/show-report.sh"
      provides: "Enhanced report showing update mode results with package-level granularity"
      contains: "UPGRADED_PACKAGES"
  key_links:
    - from: "setup"
      to: "scripts/lib/state.sh"
      via: "state_exists check for mode detection"
      pattern: "state_exists"
    - from: "setup"
      to: "scripts/run-updates.sh"
      via: "calls update flow when state exists"
      pattern: "run-updates.sh"
    - from: "scripts/run-updates.sh"
      to: "scripts/update-*.sh"
      via: "calls selected update scripts"
      pattern: "source.*update-"
    - from: "scripts/show-report.sh"
      to: "UPGRADED_PACKAGES"
      via: "displays package-level upgrade details"
      pattern: "UPGRADED_PACKAGES"
---

<objective>
Integrate update mode into the main setup entry point and create the update orchestration flow.

Purpose: Make the setup script smart about detecting existing installations and routing to update mode with beautiful multi-select category selection.
Output: Modified setup entry point, new run-updates.sh orchestrator, enhanced completion report with package-level details.
</objective>

<execution_context>
@/Users/mlaws/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mlaws/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-maintenance-and-updates/04-CONTEXT.md
@.planning/phases/04-maintenance-and-updates/04-01-SUMMARY.md
@.planning/phases/04-maintenance-and-updates/04-02-SUMMARY.md
@setup
@scripts/show-report.sh
@scripts/lib/ui.sh
@scripts/lib/state.sh
@scripts/lib/logging.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update mode orchestrator</name>
  <files>scripts/run-updates.sh</files>
  <action>
Create scripts/run-updates.sh that orchestrates the update flow:

1. Source required libraries:
   ```bash
   #!/bin/bash
   set -euo pipefail

   SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "$0")/.." && pwd)}"
   . "$SCRIPT_DIR/scripts/lib/detect.sh"
   . "$SCRIPT_DIR/scripts/lib/ui.sh"
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   . "$SCRIPT_DIR/scripts/lib/backup.sh"
   . "$SCRIPT_DIR/scripts/lib/logging.sh"
   ```

2. Initialize logging:
   ```bash
   log_init
   log_info "Update mode started"
   ```

3. Show update mode header:
   ```bash
   LAST_RUN=$(state_get_last_run)

   ui_header "Update Mode"
   echo ""
   ui_info "Last setup run: $LAST_RUN"
   echo ""
   ```

4. Confirm user wants to proceed (REQUIRED per CONTEXT.md):
   ```bash
   gum style --border normal --padding "1 2" --border-foreground 212 \
     "Detected previous setup" \
     "" \
     "This will check for updates and let you choose what to refresh."

   echo ""
   if ! ui_confirm "Run updates?"; then
     ui_info "Update cancelled"
     log_info "Update cancelled by user"
     exit 0
   fi
   echo ""
   ```

5. Show multi-select category checklist (all pre-selected by default per CONTEXT.md):
   ```bash
   ui_section "Select update categories:"
   echo ""

   # Use gum choose with --no-limit for multi-select
   # All options pre-selected by default
   SELECTED=$(gum choose --no-limit \
     --selected="Update Homebrew packages" \
     --selected="Refresh dotfile symlinks" \
     --selected="Re-apply system settings" \
     --selected="Check for new apps/tools" \
     "Update Homebrew packages" \
     "Refresh dotfile symlinks" \
     "Re-apply system settings" \
     "Check for new apps/tools")

   if [ -z "$SELECTED" ]; then
     ui_info "No categories selected, exiting"
     log_info "No categories selected"
     exit 0
   fi
   ```

6. Track what was run for the report:
   ```bash
   export UPDATED_CATEGORIES=""
   export SKIPPED_CATEGORIES=""
   export UPDATE_ERRORS=""
   export UPGRADED_PACKAGES=""  # Will be populated by update-homebrew.sh
   ```

7. Run selected categories with error handling (per CONTEXT.md: stop on error, ask to continue):
   ```bash
   run_category() {
     local name="$1"
     local script="$2"

     echo ""
     if echo "$SELECTED" | grep -q "$name"; then
       log_info "Running category: $name"
       if source "$SCRIPT_DIR/scripts/$script"; then
         UPDATED_CATEGORIES="${UPDATED_CATEGORIES}${name}\n"
         log_info "Category completed: $name"
       else
         UPDATE_ERRORS="${UPDATE_ERRORS}${name}\n"
         ui_error "$name encountered errors"
         log_error "Category failed: $name"

         if ! ui_confirm "Continue with remaining categories?"; then
           ui_info "Update stopped by user"
           log_info "Update stopped by user after error"
           return 1
         fi
       fi
     else
       SKIPPED_CATEGORIES="${SKIPPED_CATEGORIES}${name}\n"
       log_info "Category skipped (not selected): $name"
     fi
   }

   run_category "Update Homebrew packages" "update-homebrew.sh" || exit 1
   run_category "Refresh dotfile symlinks" "update-dotfiles.sh" || exit 1
   run_category "Re-apply system settings" "update-system.sh" || exit 1
   run_category "Check for new apps/tools" "update-apps.sh" || exit 1
   ```

8. Update state file with completion:
   ```bash
   state_set_last_run
   state_set_phase_complete "04-maintenance-and-updates"
   log_info "State file updated"
   ```

9. Export results for report:
   ```bash
   export UPDATED_CATEGORIES
   export SKIPPED_CATEGORIES
   export UPDATE_ERRORS
   export UPGRADED_PACKAGES  # From update-homebrew.sh
   export UPDATE_MODE=true
   ```
  </action>
  <verify>
Run: bash -n scripts/run-updates.sh (syntax check)
Verify script has multi-select with all options pre-selected, proper error handling, and initializes logging.
  </verify>
  <done>
run-updates.sh shows confirmation, multi-select checklist with all pre-selected, runs selected categories with stop-on-error + continue option, uses logging, exports UPGRADED_PACKAGES for report.
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify setup entry point for mode detection</name>
  <files>setup</files>
  <action>
Modify the setup entry point to detect existing installation and route to update mode:

1. After sourcing detect.sh, also source state.sh:
   ```bash
   # Source detection library
   . "$SCRIPT_DIR/scripts/lib/detect.sh"
   # Source state library (for update mode detection)
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   ```

2. Add mode detection BEFORE the welcome message, after library sourcing:
   ```bash
   # Check for existing setup (update mode detection)
   if state_exists; then
     # Update mode - state file exists from previous run
     export UPDATE_MODE=true

     # Need gum for update mode UI
     if ! command -v gum >/dev/null 2>&1; then
       echo "Error: gum required for update mode but not found"
       echo "Please run a fresh setup first"
       exit 1
     fi

     # Source UI library
     . "$SCRIPT_DIR/scripts/lib/ui.sh"

     # Run update flow
     source "$SCRIPT_DIR/scripts/run-updates.sh"

     # Show completion report (in update mode)
     source "$SCRIPT_DIR/scripts/show-report.sh"

     exit 0
   fi

   # First-time setup continues below...
   export UPDATE_MODE=false
   ```

3. At the END of first-time setup (before show-report.sh), initialize state:
   ```bash
   # Initialize state tracking for future update mode
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   state_init
   state_set_last_run
   state_save_packages  # Save initial package list
   state_set_phase_complete "01-foundation"
   state_set_phase_complete "02-dotfiles"
   state_set_phase_complete "03-applications"
   ```

Keep all existing first-time setup code intact. The update mode detection happens early and exits before first-time code runs.
  </action>
  <verify>
Read the modified setup file and verify:
1. state.sh is sourced
2. state_exists check happens early
3. UPDATE_MODE is exported
4. Update mode exits before first-time setup code
5. First-time setup initializes state at the end and calls state_save_packages
  </verify>
  <done>
setup entry point detects existing installation via state_exists(), routes to run-updates.sh for update mode, initializes state after first-time setup including package list.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance completion report with package-level detail</name>
  <files>scripts/show-report.sh</files>
  <action>
Modify scripts/show-report.sh to handle both first-time and update mode reports, with PACKAGE-LEVEL GRANULARITY for updates (per user decision: "show what was updated - packages upgraded, configs refreshed"):

1. At the top, after sourcing libraries, check UPDATE_MODE:
   ```bash
   # Source state library for last run info
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   . "$SCRIPT_DIR/scripts/lib/logging.sh"

   # Determine report mode
   if [ "${UPDATE_MODE:-false}" = "true" ]; then
     show_update_report
   else
     show_first_time_report
   fi
   ```

2. Wrap existing report code in show_first_time_report() function.

3. Create new show_update_report() function with PACKAGE-LEVEL DETAIL:
   ```bash
   show_update_report() {
     echo ""
     ui_header "Update Complete"
     echo ""

     # Time since last update
     LAST_RUN=$(state_get_last_run)
     ui_info "Previous run: $LAST_RUN"
     ui_info "Updated: $(date)"
     echo ""

     # Package-level detail for Homebrew upgrades (NEW - per user decision)
     if [ -n "${UPGRADED_PACKAGES:-}" ]; then
       ui_section "Packages Upgraded:"
       echo ""
       # UPGRADED_PACKAGES format from update-homebrew.sh: "package version1 -> version2" per line
       echo "$UPGRADED_PACKAGES" | while read -r pkg_info; do
         [ -n "$pkg_info" ] && ui_success "  $pkg_info"
       done
       echo ""
     fi

     # Categories updated (high-level)
     if [ -n "${UPDATED_CATEGORIES:-}" ]; then
       ui_section "Categories Completed:"
       echo ""
       echo -e "$UPDATED_CATEGORIES" | while read -r cat; do
         [ -n "$cat" ] && ui_success "$cat"
       done
       echo ""
     fi

     # Categories skipped
     if [ -n "${SKIPPED_CATEGORIES:-}" ]; then
       ui_section "Skipped:"
       echo ""
       echo -e "$SKIPPED_CATEGORIES" | while read -r cat; do
         [ -n "$cat" ] && ui_info "$cat (not selected)"
       done
       echo ""
     fi

     # Errors encountered
     if [ -n "${UPDATE_ERRORS:-}" ]; then
       ui_section "Errors:"
       echo ""
       echo -e "$UPDATE_ERRORS" | while read -r cat; do
         [ -n "$cat" ] && ui_error "$cat"
       done
       echo ""
     fi

     # Backup location
     BACKUP_DIR=$(ls -td ~/.local/state/dotfiles/backups/*/ 2>/dev/null | head -1)
     if [ -n "$BACKUP_DIR" ]; then
       ui_section "Backups:"
       echo ""
       ui_info "Latest backup: $BACKUP_DIR"
       echo ""
     fi

     # Log file location
     LOG_FILE=$(log_get_file 2>/dev/null || echo "")
     if [ -n "$LOG_FILE" ] && [ -f "$LOG_FILE" ]; then
       ui_section "Logs:"
       echo ""
       ui_info "Detailed log: $LOG_FILE"
       echo ""
     fi

     # Next steps for update mode
     ui_section "Next Steps"
     echo ""
     ui_info "1. Some settings may require logout to take effect"
     ui_info "2. Check for any errors above"
     ui_info "3. Run again anytime with: ./setup"
     echo ""

     # Recommended next update
     ui_info "Recommended: Run updates monthly to keep packages current"
     echo ""
   }
   ```

4. Keep all existing show_first_time_report() content, just wrapped in the function.
  </action>
  <verify>
Run: bash -n scripts/show-report.sh (syntax check)
Verify script has both show_first_time_report and show_update_report functions.
Verify show_update_report displays UPGRADED_PACKAGES with package-level detail (specific packages and versions).
  </verify>
  <done>
show-report.sh handles both first-time and update mode, shows specific packages upgraded (e.g., nodejs 20.0->20.1), categories updated/skipped, backup location, log file location, and recommended next update timing.
  </done>
</task>

</tasks>

<verification>
- [ ] scripts/run-updates.sh passes syntax check
- [ ] setup passes syntax check and has state_exists check early
- [ ] scripts/show-report.sh passes syntax check and handles UPDATE_MODE
- [ ] Running setup twice: first time does full setup, second time enters update mode
- [ ] Update mode shows confirmation before proceeding
- [ ] Update mode shows multi-select with all categories pre-selected
- [ ] Completion report shows specific packages upgraded (package-level granularity)
- [ ] Completion report shows log file location
</verification>

<success_criteria>
1. Fresh Mac: ./setup runs full first-time flow, creates state file with package list
2. Second run: ./setup detects state file, shows "Detected previous setup", confirms, shows category selection
3. User can uncheck categories they don't want to update
4. Each selected category runs in sequence with error handling
5. Report shows SPECIFIC packages upgraded (e.g., "nodejs 20.0 -> 20.1", "git 2.40 -> 2.41")
6. Report shows what was updated, skipped, and any errors
7. Report shows log file location for detailed output
8. State file updated with new last_run timestamp and package list after updates
</success_criteria>

<output>
After completion, create `.planning/phases/04-maintenance-and-updates/04-03-SUMMARY.md`
</output>
