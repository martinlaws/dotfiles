---
phase: 04-maintenance-and-updates
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - setup
  - scripts/run-updates.sh
  - scripts/show-report.sh
autonomous: true

must_haves:
  truths:
    - "Running setup detects previous installation and shows 'Detected previous setup' message"
    - "User confirms before any updates run"
    - "User can select which update categories to run via multi-select checklist"
    - "Completion report shows what was updated and what was skipped"
  artifacts:
    - path: "setup"
      provides: "Entry point with update mode detection"
      contains: "state_exists"
    - path: "scripts/run-updates.sh"
      provides: "Update mode orchestration with multi-select category selection"
      contains: "gum choose --no-limit"
    - path: "scripts/show-report.sh"
      provides: "Enhanced report showing update mode results"
      contains: "Time since last update"
  key_links:
    - from: "setup"
      to: "scripts/lib/state.sh"
      via: "state_exists check for mode detection"
      pattern: "state_exists"
    - from: "setup"
      to: "scripts/run-updates.sh"
      via: "calls update flow when state exists"
      pattern: "run-updates.sh"
    - from: "scripts/run-updates.sh"
      to: "scripts/update-*.sh"
      via: "calls selected update scripts"
      pattern: "source.*update-"
---

<objective>
Integrate update mode into the main setup entry point and create the update orchestration flow.

Purpose: Make the setup script smart about detecting existing installations and routing to update mode with beautiful multi-select category selection.
Output: Modified setup entry point, new run-updates.sh orchestrator, enhanced completion report.
</objective>

<execution_context>
@/Users/mlaws/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mlaws/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-maintenance-and-updates/04-CONTEXT.md
@.planning/phases/04-maintenance-and-updates/04-01-SUMMARY.md
@.planning/phases/04-maintenance-and-updates/04-02-SUMMARY.md
@setup
@scripts/show-report.sh
@scripts/lib/ui.sh
@scripts/lib/state.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update mode orchestrator</name>
  <files>scripts/run-updates.sh</files>
  <action>
Create scripts/run-updates.sh that orchestrates the update flow:

1. Source required libraries:
   ```bash
   #!/bin/bash
   set -euo pipefail

   SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "$0")/.." && pwd)}"
   . "$SCRIPT_DIR/scripts/lib/detect.sh"
   . "$SCRIPT_DIR/scripts/lib/ui.sh"
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   . "$SCRIPT_DIR/scripts/lib/backup.sh"
   ```

2. Show update mode header:
   ```bash
   LAST_RUN=$(state_get_last_run)

   ui_header "Update Mode"
   echo ""
   ui_info "Last setup run: $LAST_RUN"
   echo ""
   ```

3. Confirm user wants to proceed (REQUIRED per CONTEXT.md):
   ```bash
   gum style --border normal --padding "1 2" --border-foreground 212 \
     "Detected previous setup" \
     "" \
     "This will check for updates and let you choose what to refresh."

   echo ""
   if ! ui_confirm "Run updates?"; then
     ui_info "Update cancelled"
     exit 0
   fi
   echo ""
   ```

4. Show multi-select category checklist (all pre-selected by default per CONTEXT.md):
   ```bash
   ui_section "Select update categories:"
   echo ""

   # Use gum choose with --no-limit for multi-select
   # All options pre-selected by default
   SELECTED=$(gum choose --no-limit \
     --selected="Update Homebrew packages" \
     --selected="Refresh dotfile symlinks" \
     --selected="Re-apply system settings" \
     --selected="Check for new apps/tools" \
     "Update Homebrew packages" \
     "Refresh dotfile symlinks" \
     "Re-apply system settings" \
     "Check for new apps/tools")

   if [ -z "$SELECTED" ]; then
     ui_info "No categories selected, exiting"
     exit 0
   fi
   ```

5. Track what was run for the report:
   ```bash
   export UPDATED_CATEGORIES=""
   export SKIPPED_CATEGORIES=""
   export UPDATE_ERRORS=""
   ```

6. Run selected categories with error handling (per CONTEXT.md: stop on error, ask to continue):
   ```bash
   run_category() {
     local name="$1"
     local script="$2"

     echo ""
     if echo "$SELECTED" | grep -q "$name"; then
       if source "$SCRIPT_DIR/scripts/$script"; then
         UPDATED_CATEGORIES="${UPDATED_CATEGORIES}${name}\n"
       else
         UPDATE_ERRORS="${UPDATE_ERRORS}${name}\n"
         ui_error "$name encountered errors"

         if ! ui_confirm "Continue with remaining categories?"; then
           ui_info "Update stopped by user"
           return 1
         fi
       fi
     else
       SKIPPED_CATEGORIES="${SKIPPED_CATEGORIES}${name}\n"
     fi
   }

   run_category "Update Homebrew packages" "update-homebrew.sh" || exit 1
   run_category "Refresh dotfile symlinks" "update-dotfiles.sh" || exit 1
   run_category "Re-apply system settings" "update-system.sh" || exit 1
   run_category "Check for new apps/tools" "update-apps.sh" || exit 1
   ```

7. Update state file with completion:
   ```bash
   state_set_last_run
   state_set_phase_complete "04-maintenance-and-updates"
   ```

8. Export results for report:
   ```bash
   export UPDATED_CATEGORIES
   export SKIPPED_CATEGORIES
   export UPDATE_ERRORS
   export UPDATE_MODE=true
   ```
  </action>
  <verify>
Run: bash -n scripts/run-updates.sh (syntax check)
Verify script has multi-select with all options pre-selected and proper error handling.
  </verify>
  <done>
run-updates.sh shows confirmation, multi-select checklist with all pre-selected, runs selected categories with stop-on-error + continue option.
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify setup entry point for mode detection</name>
  <files>setup</files>
  <action>
Modify the setup entry point to detect existing installation and route to update mode:

1. After sourcing detect.sh, also source state.sh:
   ```bash
   # Source detection library
   . "$SCRIPT_DIR/scripts/lib/detect.sh"
   # Source state library (for update mode detection)
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   ```

2. Add mode detection BEFORE the welcome message, after library sourcing:
   ```bash
   # Check for existing setup (update mode detection)
   if state_exists; then
     # Update mode - state file exists from previous run
     export UPDATE_MODE=true

     # Need gum for update mode UI
     if ! command -v gum >/dev/null 2>&1; then
       echo "Error: gum required for update mode but not found"
       echo "Please run a fresh setup first"
       exit 1
     fi

     # Source UI library
     . "$SCRIPT_DIR/scripts/lib/ui.sh"

     # Run update flow
     source "$SCRIPT_DIR/scripts/run-updates.sh"

     # Show completion report (in update mode)
     source "$SCRIPT_DIR/scripts/show-report.sh"

     exit 0
   fi

   # First-time setup continues below...
   export UPDATE_MODE=false
   ```

3. At the END of first-time setup (before show-report.sh), initialize state:
   ```bash
   # Initialize state tracking for future update mode
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   state_init
   state_set_last_run
   state_set_phase_complete "01-foundation"
   state_set_phase_complete "02-dotfiles"
   state_set_phase_complete "03-applications"
   ```

Keep all existing first-time setup code intact. The update mode detection happens early and exits before first-time code runs.
  </action>
  <verify>
Read the modified setup file and verify:
1. state.sh is sourced
2. state_exists check happens early
3. UPDATE_MODE is exported
4. Update mode exits before first-time setup code
5. First-time setup initializes state at the end
  </verify>
  <done>
setup entry point detects existing installation via state_exists(), routes to run-updates.sh for update mode, initializes state after first-time setup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance completion report for update mode</name>
  <files>scripts/show-report.sh</files>
  <action>
Modify scripts/show-report.sh to handle both first-time and update mode reports:

1. At the top, after sourcing libraries, check UPDATE_MODE:
   ```bash
   # Source state library for last run info
   . "$SCRIPT_DIR/scripts/lib/state.sh"

   # Determine report mode
   if [ "${UPDATE_MODE:-false}" = "true" ]; then
     show_update_report
   else
     show_first_time_report
   fi
   ```

2. Wrap existing report code in show_first_time_report() function.

3. Create new show_update_report() function:
   ```bash
   show_update_report() {
     echo ""
     ui_header "Update Complete"
     echo ""

     # Time since last update
     LAST_RUN=$(state_get_last_run)
     ui_info "Previous run: $LAST_RUN"
     ui_info "Updated: $(date)"
     echo ""

     # Categories updated
     if [ -n "${UPDATED_CATEGORIES:-}" ]; then
       ui_section "Updated:"
       echo ""
       echo -e "$UPDATED_CATEGORIES" | while read -r cat; do
         [ -n "$cat" ] && ui_success "$cat"
       done
       echo ""
     fi

     # Categories skipped
     if [ -n "${SKIPPED_CATEGORIES:-}" ]; then
       ui_section "Skipped:"
       echo ""
       echo -e "$SKIPPED_CATEGORIES" | while read -r cat; do
         [ -n "$cat" ] && ui_info "$cat (not selected)"
       done
       echo ""
     fi

     # Errors encountered
     if [ -n "${UPDATE_ERRORS:-}" ]; then
       ui_section "Errors:"
       echo ""
       echo -e "$UPDATE_ERRORS" | while read -r cat; do
         [ -n "$cat" ] && ui_error "$cat"
       done
       echo ""
     fi

     # Backup location
     BACKUP_DIR=$(ls -td ~/.local/state/dotfiles/backups/*/ 2>/dev/null | head -1)
     if [ -n "$BACKUP_DIR" ]; then
       ui_section "Backups:"
       echo ""
       ui_info "Latest backup: $BACKUP_DIR"
       echo ""
     fi

     # Next steps for update mode
     ui_section "Next Steps"
     echo ""
     ui_info "1. Some settings may require logout to take effect"
     ui_info "2. Check for any errors above"
     ui_info "3. Run again anytime with: ./setup"
     echo ""

     # Recommended next update
     ui_info "Recommended: Run updates monthly to keep packages current"
     echo ""
   }
   ```

4. Keep all existing show_first_time_report() content, just wrapped in the function.
  </action>
  <verify>
Run: bash -n scripts/show-report.sh (syntax check)
Verify script has both show_first_time_report and show_update_report functions.
  </verify>
  <done>
show-report.sh handles both first-time and update mode, shows categories updated/skipped, backup location, and recommended next update timing.
  </done>
</task>

</tasks>

<verification>
- [ ] scripts/run-updates.sh passes syntax check
- [ ] setup passes syntax check and has state_exists check early
- [ ] scripts/show-report.sh passes syntax check and handles UPDATE_MODE
- [ ] Running setup twice: first time does full setup, second time enters update mode
- [ ] Update mode shows confirmation before proceeding
- [ ] Update mode shows multi-select with all categories pre-selected
- [ ] Completion report differs between first-time and update mode
</verification>

<success_criteria>
1. Fresh Mac: ./setup runs full first-time flow, creates state file
2. Second run: ./setup detects state file, shows "Detected previous setup", confirms, shows category selection
3. User can uncheck categories they don't want to update
4. Each selected category runs in sequence with error handling
5. Report shows what was updated, skipped, and any errors
6. State file updated with new last_run timestamp after updates
</success_criteria>

<output>
After completion, create `.planning/phases/04-maintenance-and-updates/04-03-SUMMARY.md`
</output>
