---
phase: 04-maintenance-and-updates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/lib/state.sh
  - scripts/lib/backup.sh
  - scripts/lib/logging.sh
autonomous: true

must_haves:
  truths:
    - "State file exists at ~/.local/state/dotfiles/setup-state.json after first run"
    - "State file is NOT in the git repository"
    - "State file tracks installed package lists (formulae and casks)"
    - "Backups are created with timestamps before any destructive operation"
    - "Detailed logs are written to file while UI stays clean"
  artifacts:
    - path: "scripts/lib/state.sh"
      provides: "JSON state file read/write/update functions using jq, including package tracking"
      exports: ["state_init", "state_read", "state_write", "state_get_last_run", "state_set_phase_complete", "state_save_packages", "state_get_packages"]
    - path: "scripts/lib/backup.sh"
      provides: "Timestamped backup directory creation and cleanup"
      exports: ["backup_create_dir", "backup_cleanup_old", "backup_defaults", "backup_state"]
    - path: "scripts/lib/logging.sh"
      provides: "Logging functions that write verbose output to file while showing clean UI"
      exports: ["log_init", "log_info", "log_error", "log_debug", "log_cmd"]
  key_links:
    - from: "scripts/lib/state.sh"
      to: "~/.local/state/dotfiles/setup-state.json"
      via: "jq read/write operations"
      pattern: "jq.*STATE_FILE"
    - from: "scripts/lib/backup.sh"
      to: "~/.local/state/dotfiles/backups/"
      via: "mkdir -p with timestamp"
      pattern: "BACKUP_DIR.*date"
    - from: "scripts/lib/logging.sh"
      to: "~/.local/state/dotfiles/logs/"
      via: "tee append to log file"
      pattern: "LOG_FILE"
---

<objective>
Create the state management, backup infrastructure, and logging system for update mode detection and safe modifications.

Purpose: Enable the setup script to detect previous runs, track what was installed (including package lists), ensure all modifications have recoverable backups, and log verbose details to file while keeping the UI clean.
Output: Three library scripts (state.sh, backup.sh, logging.sh) that other update scripts will source.
</objective>

<execution_context>
@/Users/mlaws/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mlaws/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-maintenance-and-updates/04-CONTEXT.md
@.planning/phases/04-maintenance-and-updates/04-RESEARCH.md
@scripts/lib/detect.sh
@scripts/lib/ui.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state management library with package tracking</name>
  <files>scripts/lib/state.sh</files>
  <action>
Create scripts/lib/state.sh with functions for JSON state file management:

1. Set STATE_DIR="$HOME/.local/state/dotfiles" and STATE_FILE="$STATE_DIR/setup-state.json"

2. state_init() function:
   - Create STATE_DIR with mkdir -p
   - If STATE_FILE doesn't exist, create initial JSON structure:
     ```json
     {
       "version": "1.0",
       "last_run": null,
       "phases": {},
       "packages": {
         "formulae": [],
         "casks": []
       },
       "backups": { "last_backup_dir": null }
     }
     ```
   - Use jq to create valid JSON (not echo)

3. state_exists() function:
   - Return 0 if STATE_FILE exists, 1 otherwise
   - This is how setup detects first-run vs update mode

4. state_get_last_run() function:
   - Use jq -r '.last_run' to extract timestamp
   - Return "never" if null or file missing

5. state_set_last_run() function:
   - Update .last_run with current ISO 8601 timestamp
   - Use jq with temp file pattern: jq ... > "$TMP" && mv "$TMP" "$STATE_FILE"

6. state_set_phase_complete() function:
   - Takes phase name as argument (e.g., "01-foundation")
   - Sets .phases[phase].completed_at to current timestamp
   - Use --arg for safe variable interpolation

7. state_get_phase_status() function:
   - Returns completed_at timestamp for a phase, or "not_completed"

8. state_save_packages() function (NEW - per user decision):
   - Captures current installed packages:
     ```bash
     state_save_packages() {
       local TMP=$(mktemp)
       local formulae=$(brew list --formula 2>/dev/null | jq -R -s 'split("\n") | map(select(length > 0))')
       local casks=$(brew list --cask 2>/dev/null | jq -R -s 'split("\n") | map(select(length > 0))')

       jq --argjson formulae "$formulae" --argjson casks "$casks" \
         '.packages.formulae = $formulae | .packages.casks = $casks' \
         "$STATE_FILE" > "$TMP" && mv "$TMP" "$STATE_FILE"
     }
     ```

9. state_get_packages() function (NEW):
   - Returns JSON object with formulae and casks arrays
   - Used to compare current state vs recorded state for drift detection

Export all functions. Follow existing lib/*.sh patterns (shellcheck source comments, export -f).

IMPORTANT: Use jq for ALL JSON operations. Do NOT use sed/awk/echo to construct JSON - it breaks on special characters.
  </action>
  <verify>
Run: bash -n scripts/lib/state.sh (syntax check)
Run: source scripts/lib/state.sh && state_init && cat ~/.local/state/dotfiles/setup-state.json | jq .
Verify JSON is valid, has expected structure including "packages" key with formulae and casks arrays.
  </verify>
  <done>
state.sh exists with all functions including state_save_packages() and state_get_packages(), creates valid JSON state file with package tracking, state_exists() correctly detects first-run vs update mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backup utilities library</name>
  <files>scripts/lib/backup.sh</files>
  <action>
Create scripts/lib/backup.sh with backup management functions:

1. Set BACKUP_BASE_DIR="$HOME/.local/state/dotfiles/backups"

2. backup_create_dir() function:
   - Create timestamped directory: BACKUP_DIR="$BACKUP_BASE_DIR/$(date +%Y-%m-%dT%H-%M-%S)"
   - mkdir -p "$BACKUP_DIR"
   - Export BACKUP_DIR for use by other scripts
   - Return the directory path

3. backup_cleanup_old() function:
   - Keep only last 5 backup directories (per research recommendation)
   - cd "$BACKUP_BASE_DIR" && ls -t | tail -n +6 | xargs rm -rf
   - Handle case where fewer than 5 backups exist gracefully

4. backup_defaults() function:
   - Takes domain as argument (e.g., "com.apple.dock")
   - Exports to $BACKUP_DIR/$domain.plist using: defaults export "$domain" "$BACKUP_DIR/$domain.plist"
   - Handle errors gracefully (some domains may not exist)

5. backup_state() function:
   - Copy current state file to backup directory
   - cp "$STATE_FILE" "$BACKUP_DIR/setup-state.json" (if exists)

6. backup_get_last_dir() function:
   - Return most recent backup directory path
   - Used for showing user where backups are stored

Source state.sh at the top (needs STATE_FILE variable).
Follow existing lib/*.sh patterns.
  </action>
  <verify>
Run: bash -n scripts/lib/backup.sh (syntax check)
Run: source scripts/lib/state.sh && source scripts/lib/backup.sh && backup_create_dir && ls -la ~/.local/state/dotfiles/backups/
Verify timestamped directory was created.
  </verify>
  <done>
backup.sh exists with all functions, creates timestamped backup directories, backup_defaults exports plist files correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create logging library</name>
  <files>scripts/lib/logging.sh</files>
  <action>
Create scripts/lib/logging.sh with logging functions (per user decision: "Write detailed logs to file automatically, keep UI clean"):

1. Set LOG_DIR="$HOME/.local/state/dotfiles/logs" and LOG_FILE="$LOG_DIR/setup-$(date +%Y-%m-%d).log"

2. log_init() function:
   - Create LOG_DIR with mkdir -p
   - Start new log session with timestamp header:
     ```bash
     log_init() {
       mkdir -p "$LOG_DIR"
       echo "" >> "$LOG_FILE"
       echo "========================================" >> "$LOG_FILE"
       echo "Session started: $(date '+%Y-%m-%d %H:%M:%S')" >> "$LOG_FILE"
       echo "========================================" >> "$LOG_FILE"
     }
     ```

3. log_info() function:
   - Writes to log file only (not terminal)
   - Format: [INFO] timestamp message
     ```bash
     log_info() {
       echo "[INFO] $(date '+%H:%M:%S') $*" >> "$LOG_FILE"
     }
     ```

4. log_error() function:
   - Writes to log file only
   - Format: [ERROR] timestamp message
     ```bash
     log_error() {
       echo "[ERROR] $(date '+%H:%M:%S') $*" >> "$LOG_FILE"
     }
     ```

5. log_debug() function:
   - Writes verbose debug info to log file
   - Format: [DEBUG] timestamp message

6. log_cmd() function:
   - Runs a command, captures output to log file, shows only success/failure to terminal
   - This is the key function that keeps UI clean while logging everything
     ```bash
     log_cmd() {
       local desc="$1"
       shift
       log_info "Running: $*"
       if output=$("$@" 2>&1); then
         log_info "Success: $desc"
         echo "$output" >> "$LOG_FILE"
         return 0
       else
         log_error "Failed: $desc"
         echo "$output" >> "$LOG_FILE"
         return 1
       fi
     }
     ```

7. log_get_file() function:
   - Returns current log file path
   - Used to show user where logs are

Export all functions. Follow existing lib/*.sh patterns.
  </action>
  <verify>
Run: bash -n scripts/lib/logging.sh (syntax check)
Run: source scripts/lib/logging.sh && log_init && log_info "test message" && cat ~/.local/state/dotfiles/logs/*.log | tail -5
Verify log file exists and contains the test message.
  </verify>
  <done>
logging.sh exists with all functions, writes detailed logs to ~/.local/state/dotfiles/logs/, log_cmd runs commands with output captured to log while keeping terminal clean.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add jq to Brewfile if missing</name>
  <files>homebrew/Brewfile</files>
  <action>
Check if jq is already in homebrew/Brewfile. If not, add it to the CLI tools section:

```
brew "jq"                          # JSON processor for state file management
```

jq is required for state.sh to work. It should be installed early in the setup process.

Also verify jq is listed in scripts/install-tools.sh's expected tools if there's a verification step there.
  </action>
  <verify>
Run: grep -q 'brew "jq"' homebrew/Brewfile && echo "jq present" || echo "jq missing"
  </verify>
  <done>
jq is in Brewfile and will be installed during Phase 1 tools installation.
  </done>
</task>

</tasks>

<verification>
- [ ] scripts/lib/state.sh exists and passes bash -n syntax check
- [ ] scripts/lib/backup.sh exists and passes bash -n syntax check
- [ ] scripts/lib/logging.sh exists and passes bash -n syntax check
- [ ] state_init creates ~/.local/state/dotfiles/setup-state.json with valid JSON including packages key
- [ ] state_exists returns 0 when file exists, 1 when missing
- [ ] state_save_packages() captures current formulae and casks lists
- [ ] backup_create_dir creates timestamped directory
- [ ] log_init creates log file, log_info/log_error write to it
- [ ] jq is in Brewfile
- [ ] State file location is NOT inside the dotfiles git repo
</verification>

<success_criteria>
1. New user running setup for first time: state_exists() returns 1
2. After setup completes: state file exists with last_run timestamp and package lists
3. Second run of setup: state_exists() returns 0, enabling update mode detection
4. Backups created before destructive operations have ISO 8601 timestamps
5. Old backups (>5) are automatically cleaned up
6. All verbose output goes to log file, terminal stays clean
7. Package lists (formulae + casks) are tracked in state file
</success_criteria>

<output>
After completion, create `.planning/phases/04-maintenance-and-updates/04-01-SUMMARY.md`
</output>
