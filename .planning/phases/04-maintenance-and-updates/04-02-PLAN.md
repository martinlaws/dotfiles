---
phase: 04-maintenance-and-updates
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - scripts/update-homebrew.sh
  - scripts/update-dotfiles.sh
  - scripts/update-system.sh
  - scripts/update-apps.sh
autonomous: true

must_haves:
  truths:
    - "User sees dry-run preview before Homebrew upgrades are applied"
    - "User is warned about modified dotfiles before stow --restow"
    - "User sees current vs expected system settings diff before changes"
    - "User is shown packages in Brewfile but not installed"
  artifacts:
    - path: "scripts/update-homebrew.sh"
      provides: "brew update && upgrade with dry-run preview and confirmation"
      contains: "brew upgrade --dry-run"
    - path: "scripts/update-dotfiles.sh"
      provides: "stow --restow with conflict detection including content drift"
      contains: "stow.*--restow"
    - path: "scripts/update-system.sh"
      provides: "defaults write with drift detection, type-aware comparison, and backup"
      contains: "defaults read"
    - path: "scripts/update-apps.sh"
      provides: "Brewfile drift detection for casks"
      contains: "brew list --cask"
  key_links:
    - from: "scripts/update-homebrew.sh"
      to: "scripts/lib/backup.sh"
      via: "backup before upgrade"
      pattern: "backup_create_dir"
    - from: "scripts/update-dotfiles.sh"
      to: "scripts/lib/state.sh"
      via: "symlink conflict tracking with content diff"
      pattern: "diff.*readlink"
    - from: "scripts/update-system.sh"
      to: "scripts/lib/backup.sh"
      via: "backup_defaults before changes"
      pattern: "backup_defaults"
---

<objective>
Create the four update category scripts that handle Homebrew upgrades, dotfile refresh, system settings reapplication, and new app detection.

Purpose: Implement the core update operations that users select via multi-select checklist. Each script is standalone, handles its own backup, shows previews, and confirms before making changes.
Output: Four update scripts that can be called independently or together from the main update flow.
</objective>

<execution_context>
@/Users/mlaws/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mlaws/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-maintenance-and-updates/04-CONTEXT.md
@.planning/phases/04-maintenance-and-updates/04-RESEARCH.md
@.planning/phases/04-maintenance-and-updates/04-01-SUMMARY.md
@scripts/lib/detect.sh
@scripts/lib/ui.sh
@scripts/lib/state.sh
@scripts/lib/backup.sh
@scripts/lib/logging.sh
@homebrew/Brewfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Homebrew update script</name>
  <files>scripts/update-homebrew.sh</files>
  <action>
Create scripts/update-homebrew.sh that handles Homebrew package updates:

1. Source required libraries:
   ```bash
   SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "$0")/.." && pwd)}"
   . "$SCRIPT_DIR/scripts/lib/detect.sh"
   . "$SCRIPT_DIR/scripts/lib/ui.sh"
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   . "$SCRIPT_DIR/scripts/lib/backup.sh"
   . "$SCRIPT_DIR/scripts/lib/logging.sh"
   ```

2. ui_section "Updating Homebrew Packages"

3. Run `brew update` with spinner (ui_spin "Updating Homebrew..." brew update)

4. Check for outdated packages:
   ```bash
   OUTDATED=$(brew outdated)
   if [ -z "$OUTDATED" ]; then
     ui_success "All packages up to date"
     return 0  # or exit 0 if called standalone
   fi
   ```

5. Show dry-run preview:
   ```bash
   ui_info "Packages to upgrade:"
   brew upgrade --dry-run
   ```

6. Confirm before proceeding:
   ```bash
   if ! ui_confirm "Apply these upgrades?"; then
     ui_info "Homebrew upgrade skipped"
     return 0
   fi
   ```

7. Create backup before upgrade:
   ```bash
   backup_create_dir
   # Save current package versions
   brew list --formula --versions > "$BACKUP_DIR/brew-formulae.txt"
   brew list --cask --versions > "$BACKUP_DIR/brew-casks.txt"
   ui_info "Backup saved to: $BACKUP_DIR"
   ```

8. Run the upgrade and capture which packages were upgraded (for report):
   ```bash
   log_info "Starting brew upgrade"
   UPGRADE_OUTPUT=$(brew upgrade 2>&1)
   UPGRADE_STATUS=$?
   log_info "$UPGRADE_OUTPUT"

   if [ $UPGRADE_STATUS -eq 0 ]; then
     # Parse upgraded packages from output for the report
     # brew upgrade output format: "==> Upgrading package_name version1 -> version2"
     export UPGRADED_PACKAGES=$(echo "$UPGRADE_OUTPUT" | grep -E "^==> Upgrading" | sed 's/==> Upgrading //' || echo "")
     ui_success "Homebrew packages upgraded"
   else
     ui_error "Some packages failed to upgrade"
     return 1
   fi
   ```

9. Save updated package list to state:
   ```bash
   state_save_packages
   log_info "Package list updated in state file"
   ```

10. Cleanup old backups: backup_cleanup_old

Follow existing script patterns (set -euo pipefail at top, proper error handling).
  </action>
  <verify>
Run: bash -n scripts/update-homebrew.sh (syntax check)
Verify script sources all required libraries, has dry-run preview before upgrade, and exports UPGRADED_PACKAGES for report.
  </verify>
  <done>
update-homebrew.sh shows dry-run preview, confirms with user, creates backup, upgrades packages, captures upgraded package names for report, saves package list to state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dotfiles update script with content drift detection</name>
  <files>scripts/update-dotfiles.sh</files>
  <action>
Create scripts/update-dotfiles.sh that refreshes symlinks with conflict detection INCLUDING content drift (per user decision: "Detect if symlink target differs from repo"):

1. Source required libraries (same pattern as Task 1)

2. ui_section "Refreshing Dotfile Symlinks"

3. Define stow packages to refresh (same list as symlink-dotfiles.sh):
   ```bash
   STOW_PACKAGES="git zsh hyper vscode ssh starship"
   STOW_DIR="$SCRIPT_DIR/dotfiles"
   ```

4. Check for conflicts before restowing. For each expected symlink - NOW WITH CONTENT DIFF:
   ```bash
   check_dotfile_conflict() {
     local target="$1"
     local expected_source="$2"

     if [ -L "$target" ]; then
       # It's a symlink - check if it points to our repo
       CURRENT_LINK=$(readlink "$target")
       if [[ "$CURRENT_LINK" != *"$SCRIPT_DIR"* ]]; then
         ui_info "Warning: $target points to unexpected location: $CURRENT_LINK"
         return 1
       fi

       # NEW: Check for content drift - symlink target may differ from repo source
       # This catches cases where user edited the symlink target directly
       ACTUAL_CONTENT="$CURRENT_LINK"
       if [ -f "$ACTUAL_CONTENT" ] && [ -f "$expected_source" ]; then
         if ! diff -q "$ACTUAL_CONTENT" "$expected_source" >/dev/null 2>&1; then
           ui_info "Warning: $target content differs from repo version"
           echo "  Symlink points to: $ACTUAL_CONTENT"
           echo "  Repo source: $expected_source"
           echo ""
           # Show a brief diff
           diff --color=auto -u "$expected_source" "$ACTUAL_CONTENT" | head -20 || true
           echo ""
           if ui_confirm "Update repo with current version before restow?"; then
             cp "$ACTUAL_CONTENT" "$expected_source"
             ui_success "Repo updated with your changes"
           else
             ui_info "Will overwrite with repo version on restow"
           fi
         fi
       fi
     elif [ -f "$target" ]; then
       # Regular file - user may have edited it directly (not a symlink at all)
       ui_info "Warning: $target is a regular file, not a symlink"
       if ui_confirm "Move $target to repo and create symlink?"; then
         cp "$target" "$expected_source"
         rm "$target"
         ui_success "Moved to repo"
       else
         ui_info "Skipping $target"
         return 1
       fi
     fi
     return 0
   }
   ```

5. Show what will be restowed:
   ```bash
   ui_info "Will refresh symlinks for: $STOW_PACKAGES"
   echo ""
   stow --simulate -v -R -d "$STOW_DIR" -t "$HOME" $STOW_PACKAGES 2>&1 | head -20
   ```

6. Confirm before proceeding:
   ```bash
   if ! ui_confirm "Refresh these symlinks?"; then
     ui_info "Symlink refresh skipped"
     return 0
   fi
   ```

7. Run stow --restow for each package:
   ```bash
   for pkg in $STOW_PACKAGES; do
     if stow -R -d "$STOW_DIR" -t "$HOME" "$pkg" 2>/dev/null; then
       ui_success "Restowed: $pkg"
     else
       ui_error "Failed to restow: $pkg"
       # Continue to next package, don't abort
     fi
   done
   ```

Note: stow --restow (-R) is idempotent - safe to run multiple times.
  </action>
  <verify>
Run: bash -n scripts/update-dotfiles.sh (syntax check)
Verify script has conflict detection WITH content diff comparison (diff command checking symlink target vs repo source), and uses stow --restow.
  </verify>
  <done>
update-dotfiles.sh detects symlink conflicts, checks for content drift between symlink target and repo source using diff, offers to move user edits to repo before restowing, uses stow --restow for safe refresh.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create system settings update script with type-aware comparison</name>
  <files>scripts/update-system.sh</files>
  <action>
Create scripts/update-system.sh that reapplies macOS defaults with drift detection AND type-aware comparison (per checker: handle int/bool type normalization):

1. Source required libraries

2. ui_section "Checking System Settings"

3. Define expected settings (same as configure-system.sh):
   ```bash
   # Format: "description|domain|key|type|value"
   SETTINGS=(
     "Dock autohide|com.apple.dock|autohide|bool|true"
     "Dock autohide delay|com.apple.dock|autohide-delay|float|0"
     "Dock autohide speed|com.apple.dock|autohide-time-modifier|float|0.15"
     "Dock icon size|com.apple.dock|tilesize|int|48"
     "Show file extensions|NSGlobalDomain|AppleShowAllExtensions|bool|true"
     "Disable press-and-hold|NSGlobalDomain|ApplePressAndHoldEnabled|bool|false"
     "Key repeat rate|NSGlobalDomain|KeyRepeat|int|2"
     "Key repeat delay|NSGlobalDomain|InitialKeyRepeat|int|15"
     "Finder column view|com.apple.finder|FXPreferredViewStyle|string|clmv"
   )
   ```

4. Type-aware comparison function (NEW - addresses checker issue):
   ```bash
   # Compare values with type normalization to avoid false positives
   values_match() {
     local type="$1"
     local current="$2"
     local expected="$3"

     case "$type" in
       bool)
         # Normalize: true/1/TRUE -> 1, false/0/FALSE -> 0
         local curr_norm=$( [[ "$current" =~ ^(true|1|TRUE)$ ]] && echo "1" || echo "0" )
         local exp_norm=$( [[ "$expected" =~ ^(true|1|TRUE)$ ]] && echo "1" || echo "0" )
         [ "$curr_norm" = "$exp_norm" ]
         ;;
       int)
         # Compare as integers (handles "48" vs 48)
         [ "$current" -eq "$expected" ] 2>/dev/null
         ;;
       float)
         # Compare floats with bc (handles "0.15" vs 0.15)
         # Use awk for float comparison since bc may not be available
         awk "BEGIN { exit !($current == $expected) }" 2>/dev/null
         ;;
       string)
         # Direct string comparison
         [ "$current" = "$expected" ]
         ;;
       *)
         # Default to string comparison
         [ "$current" = "$expected" ]
         ;;
     esac
   }
   ```

5. Check each setting for drift using type-aware comparison:
   ```bash
   DRIFTED=()
   ui_info "Checking for settings drift..."
   echo ""

   for setting in "${SETTINGS[@]}"; do
     IFS='|' read -r desc domain key type value <<< "$setting"

     # Get current value
     CURRENT=$(defaults read "$domain" "$key" 2>/dev/null || echo "<not set>")

     # Compare using type-aware function
     if [ "$CURRENT" = "<not set>" ] || ! values_match "$type" "$CURRENT" "$value"; then
       echo "  $desc: $CURRENT -> $value"
       DRIFTED+=("$setting")
     fi
   done
   ```

6. If no drift, exit early:
   ```bash
   if [ ${#DRIFTED[@]} -eq 0 ]; then
     ui_success "All system settings match expected values"
     return 0
   fi
   ```

7. Show drift summary and confirm:
   ```bash
   echo ""
   ui_info "${#DRIFTED[@]} settings differ from expected values"

   if ! ui_confirm "Re-apply these settings?"; then
     ui_info "System settings update skipped"
     return 0
   fi
   ```

8. Backup current settings before changes:
   ```bash
   backup_create_dir
   backup_defaults "com.apple.dock"
   backup_defaults "com.apple.finder"
   backup_defaults "NSGlobalDomain"
   ui_info "Backup saved to: $BACKUP_DIR"
   ```

9. Apply drifted settings:
   ```bash
   for setting in "${DRIFTED[@]}"; do
     IFS='|' read -r desc domain key type value <<< "$setting"
     defaults write "$domain" "$key" "-$type" "$value"
     ui_success "Applied: $desc"
   done
   ```

10. Restart affected services:
   ```bash
   ui_info "Restarting Dock and Finder..."
   killall Dock 2>/dev/null || true
   killall Finder 2>/dev/null || true
   ui_success "System settings updated"
   ui_info "Note: Some changes may require logout to take full effect"
   ```
  </action>
  <verify>
Run: bash -n scripts/update-system.sh (syntax check)
Verify script has values_match() function with type-aware comparison for bool/int/float/string types, reads current defaults, compares to expected, and shows diff before applying.
  </verify>
  <done>
update-system.sh detects settings drift with type-aware comparison (normalizes bool true/1, compares int numerically, handles float), shows current vs expected values, backs up before changes, reapplies only drifted settings.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create apps update script with correct Brewfile path</name>
  <files>scripts/update-apps.sh</files>
  <action>
Create scripts/update-apps.sh that handles Brewfile drift for casks (FIXED: use correct Brewfile path per checker):

1. Source required libraries

2. ui_section "Checking Applications"

3. Get installed casks vs Brewfile casks (FIXED - use homebrew/Brewfile not Brewfile.casks):
   ```bash
   # CORRECT PATH: homebrew/Brewfile (single file, not split)
   BREWFILE="$SCRIPT_DIR/homebrew/Brewfile"

   # Get what's installed
   INSTALLED_CASKS=$(brew list --cask 2>/dev/null | sort)

   # Get what's in Brewfile (extract cask names from main Brewfile)
   # Pattern: cask "app-name" or cask "app-name", ...
   BREWFILE_CASKS=$(grep "^cask " "$BREWFILE" 2>/dev/null | sed 's/cask "\([^"]*\)".*/\1/' | sort)
   ```

4. Find manually installed casks (installed but not in Brewfile):
   ```bash
   MANUAL_INSTALLS=$(comm -23 <(echo "$INSTALLED_CASKS") <(echo "$BREWFILE_CASKS"))

   if [ -n "$MANUAL_INSTALLS" ]; then
     ui_info "Found manually installed apps not in Brewfile:"
     echo "$MANUAL_INSTALLS" | while read -r cask; do
       echo "  - $cask"
     done
     echo ""

     if ui_confirm "Add these to Brewfile?"; then
       # Backup Brewfile first
       cp "$BREWFILE" "$BREWFILE.backup.$(date +%Y%m%d-%H%M%S)"

       echo "$MANUAL_INSTALLS" | while read -r cask; do
         echo "cask \"$cask\"" >> "$BREWFILE"
       done
       ui_success "Added to Brewfile (backup saved)"
     fi
   fi
   ```

5. Find missing casks (in Brewfile but not installed):
   ```bash
   MISSING_CASKS=$(comm -13 <(echo "$INSTALLED_CASKS") <(echo "$BREWFILE_CASKS"))

   if [ -n "$MISSING_CASKS" ]; then
     ui_info "Apps in Brewfile but not installed:"
     echo "$MISSING_CASKS" | while read -r cask; do
       echo "  - $cask"
     done
     echo ""

     CHOICE=$(gum choose "Install them" "Remove from Brewfile" "Skip")

     case "$CHOICE" in
       "Install them")
         echo "$MISSING_CASKS" | while read -r cask; do
           ui_spin "Installing $cask..." brew install --cask "$cask"
         done
         ;;
       "Remove from Brewfile")
         cp "$BREWFILE" "$BREWFILE.backup.$(date +%Y%m%d-%H%M%S)"
         echo "$MISSING_CASKS" | while read -r cask; do
           sed -i '' "/^cask \"$cask\"/d" "$BREWFILE"
         done
         ui_success "Removed from Brewfile (backup saved)"
         ;;
       "Skip")
         ui_info "Skipped"
         ;;
     esac
   fi
   ```

6. If nothing to do:
   ```bash
   if [ -z "$MANUAL_INSTALLS" ] && [ -z "$MISSING_CASKS" ]; then
     ui_success "All Brewfile apps are in sync"
   fi
   ```

Handle the case where gum is not available (fall back to simpler prompt).
  </action>
  <verify>
Run: bash -n scripts/update-apps.sh (syntax check)
Verify script uses BREWFILE="$SCRIPT_DIR/homebrew/Brewfile" (not Brewfile.casks), and correctly extracts cask names with grep '^cask '.
  </verify>
  <done>
update-apps.sh uses correct path homebrew/Brewfile, extracts cask lines from main Brewfile, detects drift between installed casks and Brewfile, offers to sync in either direction.
  </done>
</task>

</tasks>

<verification>
- [ ] scripts/update-homebrew.sh passes syntax check and has dry-run preview
- [ ] scripts/update-dotfiles.sh passes syntax check, uses stow --restow, AND has content diff comparison
- [ ] scripts/update-system.sh passes syntax check, has drift detection with type-aware values_match()
- [ ] scripts/update-apps.sh passes syntax check, uses correct path homebrew/Brewfile
- [ ] All scripts source required libraries correctly (including logging.sh)
- [ ] All scripts create backups before destructive operations
- [ ] All scripts confirm with user before making changes
</verification>

<success_criteria>
1. Each script can be run standalone or as part of update flow
2. User always sees preview/dry-run before changes are made
3. User must confirm before any destructive operation
4. Backups are created automatically
5. Scripts handle errors gracefully (warn and continue where appropriate)
6. UI is consistent with first-time setup (uses ui_* functions)
7. Dotfile content drift is detected by comparing symlink target content to repo source
8. System settings comparison handles type differences (bool 1/true, int string/number)
9. App sync uses correct homebrew/Brewfile path
</success_criteria>

<output>
After completion, create `.planning/phases/04-maintenance-and-updates/04-02-SUMMARY.md`
</output>
