---
phase: 04-maintenance-and-updates
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - scripts/update-homebrew.sh
  - scripts/update-dotfiles.sh
  - scripts/update-system.sh
  - scripts/update-apps.sh
autonomous: true

must_haves:
  truths:
    - "User sees dry-run preview before Homebrew upgrades are applied"
    - "User is warned about modified dotfiles before stow --restow"
    - "User sees current vs expected system settings diff before changes"
    - "User is shown packages in Brewfile but not installed"
  artifacts:
    - path: "scripts/update-homebrew.sh"
      provides: "brew update && upgrade with dry-run preview and confirmation"
      contains: "brew upgrade --dry-run"
    - path: "scripts/update-dotfiles.sh"
      provides: "stow --restow with conflict detection"
      contains: "stow.*--restow"
    - path: "scripts/update-system.sh"
      provides: "defaults write with drift detection and backup"
      contains: "defaults read"
    - path: "scripts/update-apps.sh"
      provides: "Brewfile drift detection for casks"
      contains: "brew list --cask"
  key_links:
    - from: "scripts/update-homebrew.sh"
      to: "scripts/lib/backup.sh"
      via: "backup before upgrade"
      pattern: "backup_create_dir"
    - from: "scripts/update-dotfiles.sh"
      to: "scripts/lib/state.sh"
      via: "symlink conflict tracking"
      pattern: "readlink"
    - from: "scripts/update-system.sh"
      to: "scripts/lib/backup.sh"
      via: "backup_defaults before changes"
      pattern: "backup_defaults"
---

<objective>
Create the four update category scripts that handle Homebrew upgrades, dotfile refresh, system settings reapplication, and new app detection.

Purpose: Implement the core update operations that users select via multi-select checklist. Each script is standalone, handles its own backup, shows previews, and confirms before making changes.
Output: Four update scripts that can be called independently or together from the main update flow.
</objective>

<execution_context>
@/Users/mlaws/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mlaws/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-maintenance-and-updates/04-CONTEXT.md
@.planning/phases/04-maintenance-and-updates/04-RESEARCH.md
@.planning/phases/04-maintenance-and-updates/04-01-SUMMARY.md
@scripts/lib/detect.sh
@scripts/lib/ui.sh
@scripts/lib/state.sh
@scripts/lib/backup.sh
@homebrew/Brewfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Homebrew update script</name>
  <files>scripts/update-homebrew.sh</files>
  <action>
Create scripts/update-homebrew.sh that handles Homebrew package updates:

1. Source required libraries:
   ```bash
   SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "$0")/.." && pwd)}"
   . "$SCRIPT_DIR/scripts/lib/detect.sh"
   . "$SCRIPT_DIR/scripts/lib/ui.sh"
   . "$SCRIPT_DIR/scripts/lib/state.sh"
   . "$SCRIPT_DIR/scripts/lib/backup.sh"
   ```

2. ui_section "Updating Homebrew Packages"

3. Run `brew update` with spinner (ui_spin "Updating Homebrew..." brew update)

4. Check for outdated packages:
   ```bash
   OUTDATED=$(brew outdated)
   if [ -z "$OUTDATED" ]; then
     ui_success "All packages up to date"
     return 0  # or exit 0 if called standalone
   fi
   ```

5. Show dry-run preview:
   ```bash
   ui_info "Packages to upgrade:"
   brew upgrade --dry-run
   ```

6. Confirm before proceeding:
   ```bash
   if ! ui_confirm "Apply these upgrades?"; then
     ui_info "Homebrew upgrade skipped"
     return 0
   fi
   ```

7. Create backup before upgrade:
   ```bash
   backup_create_dir
   # Save current package versions
   brew list --formula --versions > "$BACKUP_DIR/brew-formulae.txt"
   brew list --cask --versions > "$BACKUP_DIR/brew-casks.txt"
   ui_info "Backup saved to: $BACKUP_DIR"
   ```

8. Run the upgrade:
   ```bash
   if brew upgrade; then
     ui_success "Homebrew packages upgraded"
   else
     ui_error "Some packages failed to upgrade"
     return 1
   fi
   ```

9. Cleanup old backups: backup_cleanup_old

Follow existing script patterns (set -euo pipefail at top, proper error handling).
  </action>
  <verify>
Run: bash -n scripts/update-homebrew.sh (syntax check)
Verify script sources all required libraries and has dry-run preview before upgrade.
  </verify>
  <done>
update-homebrew.sh shows dry-run preview, confirms with user, creates backup, then upgrades packages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dotfiles update script</name>
  <files>scripts/update-dotfiles.sh</files>
  <action>
Create scripts/update-dotfiles.sh that refreshes symlinks with conflict detection:

1. Source required libraries (same pattern as Task 1)

2. ui_section "Refreshing Dotfile Symlinks"

3. Define stow packages to refresh (same list as symlink-dotfiles.sh):
   ```bash
   STOW_PACKAGES="git zsh hyper vscode ssh starship"
   STOW_DIR="$SCRIPT_DIR/dotfiles"
   ```

4. Check for conflicts before restowing. For each expected symlink:
   ```bash
   check_dotfile_conflict() {
     local target="$1"
     local expected_source="$2"

     if [ -L "$target" ]; then
       # It's a symlink - check if it points to our repo
       CURRENT=$(readlink "$target")
       if [[ "$CURRENT" != *"$SCRIPT_DIR"* ]]; then
         ui_info "Warning: $target points to unexpected location: $CURRENT"
         return 1
       fi
     elif [ -f "$target" ]; then
       # Regular file - user may have edited it directly
       ui_info "Warning: $target is a regular file, not a symlink"
       if ui_confirm "Move $target to repo and create symlink?"; then
         cp "$target" "$expected_source"
         rm "$target"
         ui_success "Moved to repo"
       else
         ui_info "Skipping $target"
         return 1
       fi
     fi
     return 0
   }
   ```

5. Show what will be restowed:
   ```bash
   ui_info "Will refresh symlinks for: $STOW_PACKAGES"
   echo ""
   stow --simulate -v -R -d "$STOW_DIR" -t "$HOME" $STOW_PACKAGES 2>&1 | head -20
   ```

6. Confirm before proceeding:
   ```bash
   if ! ui_confirm "Refresh these symlinks?"; then
     ui_info "Symlink refresh skipped"
     return 0
   fi
   ```

7. Run stow --restow for each package:
   ```bash
   for pkg in $STOW_PACKAGES; do
     if stow -R -d "$STOW_DIR" -t "$HOME" "$pkg" 2>/dev/null; then
       ui_success "Restowed: $pkg"
     else
       ui_error "Failed to restow: $pkg"
       # Continue to next package, don't abort
     fi
   done
   ```

Note: stow --restow (-R) is idempotent - safe to run multiple times.
  </action>
  <verify>
Run: bash -n scripts/update-dotfiles.sh (syntax check)
Verify script has conflict detection and uses stow --restow.
  </verify>
  <done>
update-dotfiles.sh detects symlink conflicts, offers to move user edits to repo, uses stow --restow for safe refresh.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create system settings update script</name>
  <files>scripts/update-system.sh</files>
  <action>
Create scripts/update-system.sh that reapplies macOS defaults with drift detection:

1. Source required libraries

2. ui_section "Checking System Settings"

3. Define expected settings (same as configure-system.sh):
   ```bash
   # Format: "description|domain|key|type|value"
   SETTINGS=(
     "Dock autohide|com.apple.dock|autohide|bool|true"
     "Dock autohide delay|com.apple.dock|autohide-delay|float|0"
     "Dock autohide speed|com.apple.dock|autohide-time-modifier|float|0.15"
     "Dock icon size|com.apple.dock|tilesize|int|48"
     "Show file extensions|NSGlobalDomain|AppleShowAllExtensions|bool|true"
     "Disable press-and-hold|NSGlobalDomain|ApplePressAndHoldEnabled|bool|false"
     "Key repeat rate|NSGlobalDomain|KeyRepeat|int|2"
     "Key repeat delay|NSGlobalDomain|InitialKeyRepeat|int|15"
     "Finder column view|com.apple.finder|FXPreferredViewStyle|string|clmv"
   )
   ```

4. Check each setting for drift:
   ```bash
   DRIFTED=()
   ui_info "Checking for settings drift..."
   echo ""

   for setting in "${SETTINGS[@]}"; do
     IFS='|' read -r desc domain key type value <<< "$setting"

     # Get current value
     CURRENT=$(defaults read "$domain" "$key" 2>/dev/null || echo "<not set>")

     # Compare (handle type differences)
     if [ "$CURRENT" != "$value" ]; then
       echo "  $desc: $CURRENT -> $value"
       DRIFTED+=("$setting")
     fi
   done
   ```

5. If no drift, exit early:
   ```bash
   if [ ${#DRIFTED[@]} -eq 0 ]; then
     ui_success "All system settings match expected values"
     return 0
   fi
   ```

6. Show drift summary and confirm:
   ```bash
   echo ""
   ui_info "${#DRIFTED[@]} settings differ from expected values"

   if ! ui_confirm "Re-apply these settings?"; then
     ui_info "System settings update skipped"
     return 0
   fi
   ```

7. Backup current settings before changes:
   ```bash
   backup_create_dir
   backup_defaults "com.apple.dock"
   backup_defaults "com.apple.finder"
   backup_defaults "NSGlobalDomain"
   ui_info "Backup saved to: $BACKUP_DIR"
   ```

8. Apply drifted settings:
   ```bash
   for setting in "${DRIFTED[@]}"; do
     IFS='|' read -r desc domain key type value <<< "$setting"
     defaults write "$domain" "$key" "-$type" "$value"
     ui_success "Applied: $desc"
   done
   ```

9. Restart affected services:
   ```bash
   ui_info "Restarting Dock and Finder..."
   killall Dock 2>/dev/null || true
   killall Finder 2>/dev/null || true
   ui_success "System settings updated"
   ui_info "Note: Some changes may require logout to take full effect"
   ```
  </action>
  <verify>
Run: bash -n scripts/update-system.sh (syntax check)
Verify script reads current defaults, compares to expected, and shows diff before applying.
  </verify>
  <done>
update-system.sh detects settings drift, shows current vs expected values, backs up before changes, reapplies only drifted settings.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create apps update script</name>
  <files>scripts/update-apps.sh</files>
  <action>
Create scripts/update-apps.sh that handles Brewfile drift for casks:

1. Source required libraries

2. ui_section "Checking Applications"

3. Get installed casks vs Brewfile casks:
   ```bash
   BREWFILE="$SCRIPT_DIR/homebrew/Brewfile.casks"

   # Get what's installed
   INSTALLED_CASKS=$(brew list --cask 2>/dev/null | sort)

   # Get what's in Brewfile (extract cask names)
   BREWFILE_CASKS=$(grep "^cask " "$BREWFILE" 2>/dev/null | sed 's/cask "\([^"]*\)".*/\1/' | sort)
   ```

4. Find manually installed casks (installed but not in Brewfile):
   ```bash
   MANUAL_INSTALLS=$(comm -23 <(echo "$INSTALLED_CASKS") <(echo "$BREWFILE_CASKS"))

   if [ -n "$MANUAL_INSTALLS" ]; then
     ui_info "Found manually installed apps not in Brewfile:"
     echo "$MANUAL_INSTALLS" | while read -r cask; do
       echo "  - $cask"
     done
     echo ""

     if ui_confirm "Add these to Brewfile?"; then
       # Backup Brewfile first
       cp "$BREWFILE" "$BREWFILE.backup.$(date +%Y%m%d-%H%M%S)"

       echo "$MANUAL_INSTALLS" | while read -r cask; do
         echo "cask \"$cask\"" >> "$BREWFILE"
       done
       ui_success "Added to Brewfile (backup saved)"
     fi
   fi
   ```

5. Find missing casks (in Brewfile but not installed):
   ```bash
   MISSING_CASKS=$(comm -13 <(echo "$INSTALLED_CASKS") <(echo "$BREWFILE_CASKS"))

   if [ -n "$MISSING_CASKS" ]; then
     ui_info "Apps in Brewfile but not installed:"
     echo "$MISSING_CASKS" | while read -r cask; do
       echo "  - $cask"
     done
     echo ""

     CHOICE=$(gum choose "Install them" "Remove from Brewfile" "Skip")

     case "$CHOICE" in
       "Install them")
         echo "$MISSING_CASKS" | while read -r cask; do
           ui_spin "Installing $cask..." brew install --cask "$cask"
         done
         ;;
       "Remove from Brewfile")
         cp "$BREWFILE" "$BREWFILE.backup.$(date +%Y%m%d-%H%M%S)"
         echo "$MISSING_CASKS" | while read -r cask; do
           sed -i '' "/^cask \"$cask\"/d" "$BREWFILE"
         done
         ui_success "Removed from Brewfile (backup saved)"
         ;;
       "Skip")
         ui_info "Skipped"
         ;;
     esac
   fi
   ```

6. If nothing to do:
   ```bash
   if [ -z "$MANUAL_INSTALLS" ] && [ -z "$MISSING_CASKS" ]; then
     ui_success "All Brewfile apps are in sync"
   fi
   ```

Handle the case where gum is not available (fall back to simpler prompt).
  </action>
  <verify>
Run: bash -n scripts/update-apps.sh (syntax check)
Verify script detects manual installs and missing apps from Brewfile.
  </verify>
  <done>
update-apps.sh detects drift between installed casks and Brewfile, offers to sync in either direction.
  </done>
</task>

</tasks>

<verification>
- [ ] scripts/update-homebrew.sh passes syntax check and has dry-run preview
- [ ] scripts/update-dotfiles.sh passes syntax check and uses stow --restow
- [ ] scripts/update-system.sh passes syntax check and has drift detection
- [ ] scripts/update-apps.sh passes syntax check and handles Brewfile sync
- [ ] All scripts source required libraries correctly
- [ ] All scripts create backups before destructive operations
- [ ] All scripts confirm with user before making changes
</verification>

<success_criteria>
1. Each script can be run standalone or as part of update flow
2. User always sees preview/dry-run before changes are made
3. User must confirm before any destructive operation
4. Backups are created automatically
5. Scripts handle errors gracefully (warn and continue where appropriate)
6. UI is consistent with first-time setup (uses ui_* functions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-maintenance-and-updates/04-02-SUMMARY.md`
</output>
